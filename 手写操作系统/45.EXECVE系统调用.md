## EXECVE系统调用

`execve` 是 Linux 系统中的一个系统调用，用于执行一个新的程序文件。它是许多操作系统的核心功能，允许当前进程替换其自身的可执行代码，并以新的程序运行。这个过程被称为**进程替换**。

![EXECVE](../images/EXECVE.svg)

---

### **函数签名**

```c
#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);
```

### **参数说明**

1. **`pathname`**:
   - 表示要执行的可执行文件的路径（可以是绝对路径或相对路径）。
   - 文件必须是一个二进制可执行文件，或者是脚本文件（如带有 `#!` 的解释器脚本）。

2. **`argv[]`**:
   - 表示传递给新程序的命令行参数。
   - 第一个参数通常是程序的名称（惯例），后续参数为实际传递的参数。
   - 例如，执行 `ls -l` 时，`argv` 可能是 `{"ls", "-l", NULL}`。

3. **`envp[]`**:
   - 表示传递给新程序的环境变量。
   - 是一个以 `NULL` 结尾的字符串数组，每个字符串是 `key=value` 的形式。
   - 如果你不需要修改环境变量，可以使用 `execv`（它默认继承当前环境）。

---

### **返回值**

- 如果调用成功，`execve` 不会返回，因为调用进程的内存空间被新程序替代。
- 如果调用失败，返回 `-1`，并设置 `errno` 来指示错误原因，例如：
  - `EACCES`: 权限不足，无法执行文件。
  - `ENOENT`: 文件不存在。
  - `EINVAL`: 文件格式无效。

---

### **整体工作流程**

1. **系统调用入口**：
   - 用户程序通过系统调用接口（如 `execve()`）发起调用，进入内核态。
   - 内核的系统调用处理程序捕获调用请求，将控制权交给 `sys_execve` 函数。

2. **检查参数合法性**：
   - 内核验证传递的 `pathname` 是否有效：
     - 路径指向的文件是否存在。
     - 文件是否可执行（`X` 权限）。
   - 检查 `argv[]` 和 `envp[]` 是否为合法的指针数组，并确保它们符合格式（以 `NULL` 结束）。

3. **加载新程序**：
   - 内核通过文件系统接口找到目标可执行文件，并解析其格式（如 ELF、a.out 或脚本文件）。
   - 如果是脚本文件，内核根据 `#!` 指定的解释器递归执行 `execve`。

4. **清空当前进程的内存空间**：
   - 释放当前进程的用户空间内存，包括代码段、数据段、堆、栈等。
   - 保留内核维护的进程信息（如 PID、文件描述符表等）。

5. **分配和初始化新内存空间**：
   - 为新程序分配所需的内存区域：
     - **代码段**：加载 ELF 文件的 `.text` 部分。
     - **数据段**：加载 ELF 文件的 `.data` 和 `.bss` 部分。
     - **堆栈**：为进程分配新的用户栈并初始化。
   - 将 `argv[]` 和 `envp[]` 写入新的栈中。

6. **设置进程执行上下文**：
   - 修改进程的寄存器状态：
     - 设置指令指针（`IP/EIP/RIP`）为新程序的入口点。
     - 设置栈指针（`SP/ESP/RSP`）指向新栈的位置。
   - 配置内存页表，映射新程序的内存区域。

7. **启动新程序**：
   - 从新程序的入口点开始执行，通常是 `_start` 函数。
   - 系统调用返回到用户态时，进程的上下文已完全变为新程序。

---

### **核心组件和机制**

#### **1. 文件加载**
- **可执行文件格式**：
  - Linux 内核主要支持 ELF 格式。
  - 通过 `fs/binfmt_elf.c` 等模块解析 ELF 文件，确定各个段的加载地址和大小。
- **解释器支持**：
  - 如果文件是脚本（如 `#!/bin/bash`），内核会调用相应的解释器（如 `/bin/bash`）执行脚本。

#### **2. 内存管理**
- 内核通过虚拟内存机制管理进程的内存空间：
  - 清空当前进程的页表。
  - 创建新的页表，映射新程序的代码段、数据段和堆栈段。
  - 使用按需加载（demand paging），避免一次性加载整个程序，提高性能。

#### **3. 参数和环境变量传递**
- `argv[]` 和 `envp[]` 被复制到用户栈中，按照如下布局：
  ```
  栈顶
  +-----------------+
  |   环境变量值    |
  +-----------------+
  |   参数值        |
  +-----------------+
  |   NULL (终止符) |
  +-----------------+
  |   envp[] 指针   |
  +-----------------+
  |   argv[] 指针   |
  +-----------------+
  | argc (参数个数) |
  +-----------------+
  栈底
  ```
- 新程序的入口函数可以通过栈访问 `argc`、`argv` 和 `envp`。

#### **4. 权限和安全检查**
- 内核执行以下检查：
  - 文件权限是否允许当前用户执行。
  - 是否符合文件的运行条件（如 SUID 位设置）。
  - 检查地址空间是否会导致潜在冲突。

#### **5. 文件描述符和资源继承**
- 文件描述符：
  - 打开文件描述符默认被继承（除非标记为 `O_CLOEXEC`）。
- 信号处理：
  - 重置大部分信号处理程序为默认值。
- 当前工作目录和根目录：
  - 通常保持不变，除非特定程序更改它们。
