## 互斥量

![互斥量](../images/互斥量.svg)

互斥量（Mutex, Mutual Exclusion）的原理是通过**锁机制**来保证多线程环境下对共享资源的访问互斥，防止数据竞争和不一致问题。以下是互斥量的基本工作原理和机制：

---

**由于使用`sti / cli`来控制某一段代码的原子性的代价太大了（可能会破坏其他需要中断的程序的执行），所以需要引入一个软件机制来记录`EFLAGS`寄存器中`IF`的值，从而减少`sti / cli`指令的使用次数，确保其他需要中断的程序能够正常运行。**

---

### **核心原理**
1. **互斥访问**：  
   互斥量是一种同步原语，用于限制多个线程同时访问共享资源。它保证任何时刻只有一个线程可以持有互斥量锁，从而实现对资源的独占访问。

2. **加锁和解锁**：  
   - **加锁 (Lock)**：线程在访问共享资源之前，尝试获取互斥量。如果互斥量已经被另一个线程持有，该线程会被阻塞，直到互斥量被释放。
   - **解锁 (Unlock)**：线程完成对共享资源的操作后，释放互斥量，让其他等待的线程可以继续执行。

---

### **工作流程**
1. **初始状态**：互斥量处于“未锁定”状态（即资源是空闲的）。
2. **线程尝试加锁**：  
   - 如果互斥量是“未锁定”，线程成功获得锁，互斥量进入“锁定”状态。
   - 如果互斥量已“锁定”，线程会进入等待队列，直到锁被释放。
3. **解锁**：持有锁的线程完成工作后，释放互斥量。
4. **唤醒等待线程**：互斥量的解锁操作会唤醒一个等待队列中的线程，让它继续执行。

---

### **实现细节**
1. **原子操作**：  
   加锁和解锁操作必须是**原子性**的，以防止多个线程同时修改互斥量的状态。这通常是通过底层硬件支持的原子指令（如 `test-and-set` 或 `compare-and-swap`）实现的。

2. **等待和唤醒机制**：  
   - 如果一个线程试图获取已被锁定的互斥量，它会进入等待状态，通常通过操作系统的**阻塞**机制实现。
   - 解锁时，互斥量会通知操作系统将等待线程从阻塞队列中移出，切换到就绪状态。

3. **递归锁**：  
   一些互斥量允许同一个线程多次加锁（递归锁），但需要对应解锁次数才能完全释放。

---

### **互斥量的优点**
1. 保证数据一致性：有效避免数据竞争。
2. 提供简单的接口：加锁、解锁操作易于使用。

### **互斥量的缺点**
1. **线程阻塞**：加锁失败的线程需要等待，可能引发性能问题。
2. **死锁**：多个线程可能因加锁顺序不当而互相等待，导致死锁。
3. **优先级反转**：高优先级线程等待低优先级线程释放锁时，可能导致系统性能下降。